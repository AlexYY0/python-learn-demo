import re

if __name__ == '__main__':
    print('--------------------------正则表达式------------------------------')
    # 对应的正则表达式字符串变成：'ABC\-001'
    s = 'ABC\\-001'  # Python的字符串
    # 强烈建议使用Python的r前缀
    # 对应的正则表达式字符串不变：'ABC\-001'
    s = r'ABC\-001'  # Python的字符串
    re.match(r'^\d{3}\-\d{3,8}$', '010-12345')
    test = '010-12345'
    m = re.match(r'^\d{3}\-\d{3,8}$', test)
    print(m)
    if m:
        print('ok')
    else:
        print('failed')
    print('--------------------------切分字符串------------------------------')
    # 正常的切分代码
    print('a b   c'.split(' '))
    print(re.split(r'\s+', 'a b   c'))
    print(re.split(r'[\s\,\;]+', 'a,b;; c  d'))
    print('--------------------------分组------------------------------')
    m = re.match(r'^(\d{3})-(\d{3,8})$', '010-12345')
    print(m)
    print(m.group(0))
    print(m.group(1))
    print(m.group(2))
    print('--------------------------贪婪匹配------------------------------')
    # 正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符
    print(re.match(r'^(\d+)(0*)$', '102300').groups()) # 由于\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了
    # \d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\d+采用非贪婪匹配
    print(re.match(r'^(\d+?)(0*)$', '102300').groups())
    print('--------------------------编译正则表达式------------------------------')
    # 预编译正则表达式，以应付重复使用正则表达式，提高效率
    re_telephone = re.compile(r'^(\d{3})-(\d{3,8})$')
    print(re_telephone.match('010-12345').groups())
    print(re_telephone.match('010-8086').groups())
